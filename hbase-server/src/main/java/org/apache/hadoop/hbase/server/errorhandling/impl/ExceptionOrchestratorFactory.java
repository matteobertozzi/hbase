/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.hadoop.hbase.server.errorhandling.impl;

import java.util.ArrayList;
import java.util.List;

import org.apache.hadoop.classification.InterfaceAudience;
import org.apache.hadoop.classification.InterfaceStability;
import org.apache.hadoop.hbase.server.errorhandling.ExceptionCheckable;
import org.apache.hadoop.hbase.server.errorhandling.ExceptionVisitor;
import org.apache.hadoop.hbase.server.errorhandling.FaultInjector;

/**
 * Error factory that produces an {@link ExceptionOrchestrator}, potentially wrapped with a
 * {@link FaultInjector}.
 * @param <D> type for {@link ExceptionOrchestrator} that should be used
 * @param <T> Type of error listener that the dispatcher from this factory can communicate
 */
@InterfaceAudience.Public
@InterfaceStability.Unstable
public abstract class ExceptionOrchestratorFactory<D extends ExceptionOrchestrator<?>, T> {
  private static final List<FaultInjector<?>> faults = new ArrayList<FaultInjector<?>>();

  /**
   * Add a fault injector that will run on checks of the {@link ExceptionCheckable} generated by
   * this factory. To ensure that faults are injected, this must be called before the the handler is
   * created via {@link #createErrorHandler()}.
   * <p>
   * Exposed for TESTING.
   * @param injector fault injector to add
   * @param <E> type of exception that will be thrown on checks of
   *          {@link ExceptionCheckable#failOnError()} from created exception monitors
   */
  public static <E extends Exception> void addFaultInjector(FaultInjector<E> injector) {
    faults.add(injector);
  }

  /**
   * Complement to {@link #addFaultInjector(FaultInjector)} - removes any existing fault injectors
   * set for the factory.
   * <p>
   * Exposed for TESTING.
   */
  public static void clearFaults() {
    faults.clear();
  }

  protected final ExceptionVisitor<T> visitor;

  /**
   * @param visitor to use when building an error handler via {@link #createErrorHandler()}.
   */
  public ExceptionOrchestratorFactory(ExceptionVisitor<T> visitor) {
    this.visitor = visitor;
  }

  /**
   * Create a dispatcher with a specific visitor
   * @param visitor visitor to pass on error notifications to bound error listeners
   * @return an error dispatcher that is passes on errors to all listening objects
   */
  public final D createErrorHandler(ExceptionVisitor<T> visitor) {
    D handler = buildErrorHandler(visitor);
    // wrap with a fault injector, if we need to
    if (faults.size() > 0) {
      return wrapWithInjector(handler, faults);
    }
    return handler;
  }

  /**
   * Create a dispatcher with a specific visitor. Uses the default visitor passed in the constructor
   * @return an error dispatcher that is passes on errors to all listening objects
   */
  public final D createErrorHandler() {
    return createErrorHandler(this.visitor);
  }

  /**
   * Build an error handler. This will be wrapped via
   * {@link #wrapWithInjector(ErrorMonitorable, List)} if there are fault injectors present.
   * @return an error handler
   */
  protected abstract D buildErrorHandler(ExceptionVisitor<T> visitor);

  /**
   * Wrap the built error handler with an error injector. Subclasses should override if they need
   * custom error injection. Generally, this will just wrap calls to &ltD&gt by first checking the
   * {@link #faults} that were dynamically injected and then, if the {@link FaultInjector} didn't
   * inject a fault, that actual methods are called.
   * <p>
   * This method will only be called if there are fault injectors present. Otherwise, the handler
   * will just be built via {@link #buildErrorHandler(ExceptionVisitor)}.
   * @param delegate built delegate to wrap with injector checking
   * @param injectors injectors that should be checked
   * @return a &ltD&gt that also does {@link FaultInjector} checking
   */
  protected abstract D wrapWithInjector(D delegate, List<FaultInjector<?>> injectors);
}